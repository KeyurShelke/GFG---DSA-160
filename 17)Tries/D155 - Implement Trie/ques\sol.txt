The Trie data structure is a tree-like structure used for storing a dynamic set of strings. It allows for efficient retrieval and storage of keys, making it highly effective in handling large datasets. Trie supports operations such as insertion, search, deletion of keys, and prefix searches. In this article, we will explore the insertion and search operations and prefix searches in Trie Data Structure.

Triedatastructure1
Trie Data Structure


Table of Content

Representation of Trie Node
Insertion in Trie Data Structure - O(n) Time and O(n) Space
Searching in Trie Data Structure - O(n) Time and O(1) Space
Prefix Searching in Trie Data Structure - O(n) Time and O(1) Space
Implementation of Insert, Search and Prefix Searching Operations in Trie Data Structure
Complexity Analysis of Trie Data Structure
Representation of Trie Node
Trie data structure consists of nodes connected by edges.
Each node represents a character or a part of a string.
The root node acts as a starting point and does not store any character.

Inserting "and" in Trie data structure:

Start at the root node: The root node has no character associated with it and its wordEnd value is 0, indicating no complete word ends at this point.
First character "a": Calculate the index using 'a' - 'a' = 0. Check if the child[0] is null. Since it is, create a new TrieNode with the character "a", wordEnd set to 0, and an empty array of pointers. Move to this new node.
Second character "n": Calculate the index using 'n' - 'a' = 13. Check if child[13] is null. It is, so create a new TrieNode with the character "n", wordEnd set to 0, and an empty array of pointers. Move to this new node.
Third character "d": Calculate the index using 'd' - 'a' = 3. Check if child[3] is null. It is, so create a new TrieNode with the character "d", wordEnd set to 1 (indicating the word "and" ends here).
Inserting "ant" in Trie data structure:

Start at the root node: Root node doesn't contain any data but it keep track of every first character of every string that has been inserted.
First character "a": Calculate the index using 'a' - 'a' = 0. Check if the child[0] is null. We already have the "a" node created from the previous insertion. so move to the existing "a" node.
First character "n": Calculate the index using 'n' - 'a' = 13. Check if child[13] is null. It's not, so move to the existing "n" node.
Second character "t": Calculate the index using 't' - 'a' = 19. Check if child[19] is null. It is, so create a new TrieNode with the character "t", wordEnd set to 1 (indicating the word "ant" ends here).



Time Complexity: O(n), where n is the length of the word to insert.
Auxiliary Space: O(n)

Searching in Trie Data Structure - O(n) Time and O(1) Space
Searching for a key in Trie data structure is similar to its insert operation. However, It only compares the characters and moves down. The search can terminate due to the end of a string or lack of key in the trie. 

Here's a visual representation of searching word "dad" in Trie data structure:
Let's assume that we have successfully inserted the words "and", "ant", and "dad" into our Trie, and we have to search for specific words within the Trie data structure. Let's try searching for the word "dad":


Here's a visual representation of searching word "dad" in Trie data structure:
Let's assume that we have successfully inserted the words "and", "ant", and "dad" into our Trie, and we have to search for specific words within the Trie data structure. Let's try searching for the word "dad":

We start at the root node.
We follow the branch corresponding to the character 'd'.
We follow the branch corresponding to the character 'a'.
We follow the branch corresponding to the character 'd'.
We reach the end of the word and wordEnd flag is 1. 
This means that "dad" is present in the Trie.

Time Complexity: O(n), where n is the length of the word to search.
Auxiliary Space: O(1)

Prefix Searching in Trie Data Structure - O(n) Time and O(1) Space
Searching for a prefix in a Trie data structure is similar to searching for a key, but the search does not need to reach the end of the word. Instead, we stop as soon as we reach the end of the prefix or if any character in the prefix doesn't exist in the Trie.

Here's a visual representation of prefix searching for the word 'da' in the Trie data structure:
Let's assume that we have successfully inserted the words 'and', 'ant', and 'dad' into our Trie. Now, let's search for the prefix 'da' within the Trie data structure.

We start at the root node.
We follow the branch corresponding to the character 'd'.
We move to the node corresponding to the character 'a'.
We reach the end of the prefix "da". Since we haven't encountered any missing characters along the way, we return true.


Time Complexity: O(n), where n is the length of the word to search.
Auxiliary Space: O(1)

Implementation of Insert, Search and Prefix Searching Operations in Trie Data Structure
Now that we've learned how to insert words into a Trie, search for complete words, and perform prefix searches, let's do some hands-on practice.

We'll start by inserting the following words into the Trie: ["and", "ant", "do", "dad"].
Then, we'll search for the presence of these words: ["do", "gee", "bat"].
Finally, we'll check for the following prefixes: ["ge", "ba", "do", "de"].

Steps-by-step approach:

Create a root node with the help of TrieNode() constructor.
Store a collection of strings that have to be inserted in the Trie in a vector of strings say, arr.
Inserting all strings in Trie with the help of the insertKey() function,
Search strings with the help of searchKey() function.
Prefix searching with the help of isPrefix() function.

