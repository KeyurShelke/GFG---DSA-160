You are given an array arr[] of non-negative numbers. Each number tells you the maximum number of steps you can jump forward from that position.

For example:

If arr[i] = 3, you can jump to index i + 1, i + 2, or i + 3 from position i.
If arr[i] = 0, you cannot jump forward from that position.
Your task is to find the minimum number of jumps needed to move from the first position in the array to the last position.

Note:  Return -1 if you can't reach the end of the array.

Examples : 

Input: arr[] = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]
Output: 3 
Explanation: First jump from 1st element to 2nd element with value 3. From here we jump to 5th element with value 9, and from here we will jump to the last. 
Input: arr = [1, 4, 3, 2, 6, 7]
Output: 2 
Explanation: First we jump from the 1st to 2nd element and then jump to the last element.
Input: arr = [0, 10, 20]
Output: -1
Explanation: We cannot go anywhere from the 1st element.

Table of Content

[Naive Approach] - Using Recursion - O(n ^ n) Time and O(n) Space
[Better Approach 1] - Using Top-Down DP (Memoization) - O(n^2) Time and O(n) Space
[Better Approach 2] - Using Bottom-Up DP (Tabulation) - O(n^2) Time and O(n) Space
[Expected Approach] - Using Greedy Approach - O(n) Time and O(1) Space
[Naive Approach] - Using Recursion - O(n ^ n) Time and O(n) Space
The idea is to recursively generate all possible way of reaching the end of the array and find the one with the minimum steps required. To do so, start from the first element and for each element arr[i] recursively call for all the elements reachable from that element (i.e. i + arr[i]) and return the one with the minimum steps required.

Start from the first element and recursively call for all the elements reachable from the first element. The minimum number of jumps to reach end from first can be calculated using the minimum value from the recursive calls. 

minJumps(start, end) = 1 + Min(minJumps(k, end)) for all k reachable from start.




[Better Approach 1] - Using Top-Down DP (Memoization) - O(n^2) Time and O(n) Space
The above approach can be optimized using memoization to avoid computing the overlapping subproblems multiple times. For example in array, arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9} minJumps(3, 9) will be called two times as arr[3] is reachable from arr[1] and arr[2].
So this problem has both properties (optimal substructure and overlapping subproblems) of Dynamic Programming.
To do so, create an array memo[] of size n, where each element memo[i] stores the minimum steps required to reach end of array from index i.
For each recursive call, check if subproblem is already calculated, if so return the stored value, else operate similar to above Approach

[Better Approach 2] - Using Bottom-Up DP (Tabulation) - O(n^2) Time and O(n) Space
The above approach can further be optimized using bottom-up dp (tabulation) to minimize the space required for recursive stack. To do so, create an array dp[] of size n, where each element dp[i] stores the minimum steps required to reach end of array from index i. Start from the last index i.e. n-1, and for each index i compute the minimum steps for subarray i to n-1 and store the result in dp[i]. 




[Expected Approach] - Using Greedy Approach - O(n) Time and O(1) Space
The idea is to use greedy approach to find the minimum jumps needed to reach the end of an array. We iterate through the array and maintain two values: the maximum reachable index and the current reachable index and update them based on the array elements.

This approach has been discussed in article Minimum number of jumps to reach end | Set 2 (O(n) solution).