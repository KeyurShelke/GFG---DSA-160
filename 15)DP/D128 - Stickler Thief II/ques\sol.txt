You are given an array arr[] which represents houses arranged in a circle, where each house has a certain value. A thief aims to maximize the total stolen value without robbing two adjacent houses. Since the houses are in a circle, the first and last houses are also considered adjacent. The task is to determine the maximum amount the thief can steal.

Examples: 

Input: arr[] = [2, 2, 3, 1, 2]
Output: 5
Explanation: Maximum stolen value: arr[0] + arr[2] = 2 + 3 = 5 or arr[2] + arr[4] = 3 + 2 = 5.

Input: arr[] = [2, 3, 2]
Output: 3
Explanation: arr[0] and arr[2] can't be robbed simultaneously because they are  adjacent houses.

Input: arr[] = [1, 2, 3, 1]
Output: 4
Explanation: Maximum stolen value: arr[0] + arr[2] = 1 + 3 = 4 

Table of Content

[Naive Approach ] Using Recursion - O(2^n) Time and O(n) Space
[Better Approach - 1 ] Using Top-Down DP (Memoization) - O(n) Time and O(n) Space
[Better Approach - 2 ] Using Bottom-Up DP (Tabulation) - O(n) Time and O(n) Space
[Expected Approach ] Using Space Optimized DP - O(n) Time and O(1) Space
Main Idea to approach this problem:

This problem is extension to the problem House Robber â€“ Maximum possible stolen value. In this problem the array elements are arranged in circular fashion such that first and the last element are also adjacent. So we can not take first and last element together.

So first we can skip the last element by only considering the first n - 1 elements of the array. Then skip the first element by considering the last n - 1 elements. Then return the maximum of the two values.

[Naive Approach ] Using Recursion - O(2^n) Time and O(n) Space
The idea is to split the circular house robbery problem into two linear subproblems by considering two scenarios: one where we exclude the last house (array[0...n-2]) and another where we exclude the first house (array[1...n-1]). 

For each subproblem, we use recursion where at each house, the thief decides between stealing from the current house and skipping the previous one, or skipping the current house - always taking the maximum value possible. 
The final answer is simply the maximum result from these two scenarios, ensuring we never rob adjacent houses while handling the circular constraint where the first and last houses are considered adjacent.
Maximum-sum-in-circular-array-with-non-adjacent-element--1.webp

[Better Approach - 1 ] Using Top-Down DP (Memoization) - O(n) Time and O(n) Space
If we notice carefully, we can observe that the above recursive solution holds the following two properties of Dynamic Programming:

1. Optimal Substructure: 

Maximum amount at index j, i.e., maxValRec(arr, i, j), depends on the optimal solutions of the subproblems maxValRec(arr, i, j-1) , and maxValRec(arr, i, j-2). By comparing these optimal substructures, we can efficiently calculate the maximum amount at index j.

2. Overlapping Subproblems: 

While applying a recursive approach in this problem, we notice that certain subproblems are computed multiple times. 

There is only one parameter: j that changes in the recursive solution. So we create a 1D array of size n for memoization.
We initialize this array as -1 to indicate nothing is computed initially.
Now we modify our recursive solution to first check if the value is -1, then only make recursive calls. This way, we avoid re-computations of the same subproblems.

[Better Approach - 2 ] Using Bottom-Up DP (Tabulation) - O(n) Time and O(n) Space
 The idea is to fill the DP table based on previous values. For each index, we either include it or exclude it to compute the maximum value. The table is filled in an iterative manner from j = 2 to j = n-1.

The dynamic programming relation is as follows: 

dp[j] = max(arr[j] + dp[j-2], dp[j-1]).

[Expected Approach ] Using Space Optimized DP - O(n) Time and O(1) Space
In previous approach of dynamic programming we have derive the relation between states as given below:

dp[j] = max(arr[j] + dp[j-2], dp[j-1]).
If we observe that for calculating current dp[j] state we only need previous two values dp[j-1] and dp[j-2]. There is no need to store all the previous states.

